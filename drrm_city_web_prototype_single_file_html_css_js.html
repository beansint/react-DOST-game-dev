<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>DRRM City ‚Äî Flood Defense (Isometric Prototype)</title>
<style>
  :root{ --bg:#0f1220; --panel:#171a2a; --accent:#78e0ff; --accent2:#9af5a6; --text:#eef3ff; }
  *{box-sizing:border-box}
  html,body{height:100%;margin:0;background:radial-gradient(1200px 800px at 60% -10%,#1e2440,#0b0e1d);color:var(--text);font:500 14px/1.4 ui-sans-serif,system-ui,"Segoe UI",Roboto;}
  header{display:flex;gap:.75rem;align-items:center;justify-content:space-between;padding:14px 16px;background:linear-gradient(180deg,#12162a,#0d1020);border-bottom:1px solid #2a3055;position:sticky;top:0;z-index:10}
  header h1{margin:0;font-size:16px;letter-spacing:.2px}
  .wrap{display:grid;grid-template-columns:360px 1fr;gap:12px;height:calc(100% - 56px)}
  aside{background:var(--panel);border-right:1px solid #2a3055;padding:12px;overflow:auto}
  main{display:grid;grid-template-rows:auto 1fr auto;gap:8px;padding:10px}
  .card{background:#11162a; border:1px solid #2a3055; border-radius:14px; padding:10px}
  .toolbar{display:flex;flex-wrap:wrap;gap:8px}
  button{appearance:none;border:1px solid #2a3055;background:#121633;color:var(--text);padding:8px 10px;border-radius:10px;cursor:pointer}
  button:hover{border-color:#3a4277}
  button.active{outline:2px solid var(--accent)}
  #board{position:relative;aspect-ratio:1/1;background:linear-gradient(180deg,#0d1227,#0a0f21);border-radius:16px;border:1px solid #2a3055;overflow:hidden}
  canvas{width:100%;height:100%;image-rendering:pixelated;display:block}
  .row{display:flex;gap:8px;align-items:center;justify-content:space-between}
  .col{display:flex;flex-direction:column;gap:6px}
  .stat{font-variant-numeric:tabular-nums}
  .legend{display:grid;grid-template-columns:1.2rem 1fr;gap:.4rem .6rem;align-items:center}
  .tag{width:1.2rem;height:1.2rem;border-radius:4px;border:1px solid #2a3055}
  .tag.water{background:rgba(80,160,255,.5)}
  .tag.wall{background:#8a8fa8}
  .tag.tree{background:#3fb26e}
  .tag.canal{background:#1f6bd0}
  .tag.city{background:#f2a266}
  .notice{font-size:12px;opacity:.9}
  .range{accent-color:#78e0ff}
  .pill{font-size:12px;padding:2px 8px;border-radius:999px;border:1px solid #2a3055;background:#0e1430}
  /* tooltip */
  #tip{position:absolute; pointer-events:none; background:#0b1130; border:1px solid #2a3055; padding:6px 8px; border-radius:8px; font-size:12px; box-shadow:0 6px 20px rgba(0,0,0,0.35); display:none; white-space:nowrap}
  /* modal */
  #modal{position:fixed; inset:0; background:rgba(0,0,0,.55); display:none; align-items:center; justify-content:center; z-index:50}
  #modal .panel{min-width:360px; max-width:520px; background:#0e1430; border:1px solid #344; border-radius:16px; padding:16px; box-shadow:0 20px 60px rgba(0,0,0,.4)}
  #modal h2{margin:.2rem 0 0.4rem 0}
  #modal .grid{display:grid; grid-template-columns:auto 1fr; gap:.35rem .8rem; margin:.6rem 0 1rem}
</style>
</head>
<body>
<header>
  <h1>DRRM City ‚Äî Flood Defense (isometric)</h1>
  <div class="row" style="gap:8px">
    <button id="btnPlay">‚ñ∂ Play</button>
    <button id="btnStep">Step</button>
    <button id="btnReset">‚Ü∫ Reset</button>
    <button id="btnTests" title="Run smoke tests">üß™ Run Tests</button>
  </div>
</header>
<div class="wrap">
  <aside>
    <div class="card" style="margin-bottom:10px">
      <div class="row" style="margin-bottom:6px">
        <strong>Level</strong>
        <span class="stat" id="levelLabel">1</span>
      </div>
      <div class="row" style="margin-bottom:6px">
        <span>Budget</span>
        <span class="stat" id="budget">‚Ç±100,000</span>
      </div>
      <div class="row" style="margin-bottom:6px">
        <span>Saved City Tiles</span>
        <span class="stat" id="saved">0</span>
      </div>
      <div class="row">
        <span>Score</span>
        <span class="stat" id="score">0</span>
      </div>
    </div>

    <div class="card" style="margin-bottom:10px">
      <strong>Tools</strong>
      <div class="toolbar" style="margin-top:6px">
        <button data-tool="wall" title="Levee/Wall (‚Ç±800)">üß± Wall</button>
        <button data-tool="tree" title="Tree (‚Ç±300)">üå≥ Tree</button>
        <button data-tool="canal" title="Canal (‚Ç±600)">üï≥Ô∏è Canal</button>
        <button data-tool="erase" title="Remove (refund 40%)">ü™ì Remove</button>
        <button data-tool="pan" title="Drag to pan">üñ±Ô∏è Pan</button>
      </div>
      <div class="row" style="margin-top:8px">
        <label>Brush <input id="brush" class="range" type="range" min="1" max="3" value="1"/></label>
        <span class="pill">Isometric</span>
      </div>
      <div class="row" style="margin-top:8px">
        <label>Levee height <input id="leveeH" class="range" type="range" min="1" max="5" value="2"/></label>
        <span id="leveeHLabel" class="pill">h=2</span>
      </div>
    </div>

    <div class="card" style="margin-bottom:10px">
      <strong>Scenario & Timing</strong>
      <div class="col" style="margin-top:6px">
        <label>Scenario
          <select id="scenario">
            <option value="riverine">Riverine Barangay (upland source ‚Üí lowland city)</option>
            <option value="coastal">Coastal Storm Surge</option>
            <option value="random">Random (seeded)</option>
          </select>
        </label>
        <label>Seed <input id="seed" type="text" placeholder="auto" style="width:160px"/></label>
        <div class="row">
          <button id="btnRegen">Re-generate</button>
          <button id="btnShare">Copy Share URL</button>
        </div>
        <label>Flood duration (sec) <input id="floodSec" class="range" type="range" min="2" max="20" value="5"/></label>
        <label>Settle duration (sec) <input id="settleSec" class="range" type="range" min="2" max="20" value="5"/></label>
        <div>Timer: <span class="stat" id="timerLabel">ready</span></div>
      </div>
    </div>

    <!-- ADDED: View & Flood Settings to fix missing elements -->
    <div class="card" style="margin-bottom:10px">
      <strong>View & Flood Settings</strong>
      <div class="col" style="margin-top:6px">
        <label>Flood strength
          <input id="floodStrength" class="range" type="range" min="1" max="8" value="3" />
        </label>
        <label>Spawn side
          <select id="spawnSide">
            <option value="N">North</option>
            <option value="W">West</option>
            <option value="E">East</option>
            <option value="S">South</option>
          </select>
        </label>
        <div class="row">
          <button id="toggleHeat">Heatmap: Elevation</button>
          <button id="toggleZ">Z on/off</button>
        </div>
      </div>
    </div>

    <div class="card">
      <strong>Legend</strong>
      <div class="legend" style="margin-top:6px">
        <div class="tag water"></div><div>Water</div>
        <div class="tag wall"></div><div>Levee/Wall (heighted)</div>
        <div class="tag tree"></div><div>Tree (soil retention)</div>
        <div class="tag canal"></div><div>Canal (directed flow)</div>
        <div class="tag city"></div><div>City (protect these!)</div>
      </div>
      <p class="notice" style="margin-top:8px">Tip: canals guide flow; trees slow spread; levees block unless head overtops their height.</p>
    </div>
  </aside>

  <main>
    <div class="row card">
      <div>
        Grid: <span id="gridLabel">20√ó20</span> ¬∑ Tick <span id="tick">0</span>
      </div>
      <div class="row" style="gap:8px">
        <button id="btnPrev">‚üµ Prev Level</button>
        <button id="btnNext">Next Level ‚ü∂</button>
      </div>
    </div>
    <div id="board" class="card">
      <canvas id="c"></canvas>
      <div id="tip"></div>
    </div>
    <div class="card" id="log" style="min-height:40px"></div>
  </main>

  <!-- Level result modal -->
  <div id="modal">
    <div class="panel">
      <div class="row" style="justify-content:space-between; align-items:center">
        <h2 id="modalTitle">Level Result</h2>
        <span id="modalStatus" class="pill">‚Äî</span>
      </div>
      <div class="grid">
        <div>Saved city tiles</div><div class="stat" id="mSaved">0</div>
        <div>Budget spent</div><div class="stat" id="mSpent">‚Ç±0</div>
        <div>Score gained</div><div class="stat" id="mScore">0</div>
        <div>Required saved %</div><div class="stat" id="mReq">70%</div>
      </div>
      <div class="row" style="gap:8px; justify-content:flex-end">
        <button id="btnRetry">Retry</button>
        <button id="btnNext2">Next Level ‚ü∂</button>
      </div>
    </div>
  </div>
</div>

<script>
// Ensure DOM is parsed before accessing elements (prevents null addEventListener errors)
document.addEventListener('DOMContentLoaded', () => {
(()=>{
  // ‚Äî‚Äî‚Äî Config ‚Äî‚Äî‚Äî
  const N = 20;                   // grid size (N x N)
  const TILE_W = 48;              // iso tile width (px)
  const TILE_H = 24;              // iso tile height (px)
  const Z_SCALE = 16;             // how much elevation affects screen Y
  const TICK_MS = 22;             // simulation step
  const MAX_WATER = 5;            // max water per cell (arbitrary)
  const EDGE_SINK_RATE = 0.45;    // fraction that can escape off-map per tick
  const CANAL_CAP = 1.6;          // per-tile canal capacity ("bankfull")
  const CANAL_DEPTH = 0.25;       // effective lowering of canal bed
  const PASS_REQ_PCT = 70;        // default success threshold (ask user to tune)            // max water per cell (arbitrary)
  const COST = { wall:800, tree:300, canal:600 };
  const REFUND = 0.4;

  // ‚Äî‚Äî‚Äî State ‚Äî‚Äî‚Äî
  let level = 1, tick = 0, playing = false;
  let elevation=[], water=[], type=[], city=[], levee=[]; // arrays of size N*N
  let canalCap=[], canalNote=[]; // capacity & debug note per canal // arrays of size N*N
  let budget = 100000, score=0, savedCount=0;
  let floodTicks = 0, settleTicks = 0; // timers in ticks
  let floodLeft = 0, settleLeft = 0;   // countdowns
  let spawnSide = 'N';
  let tool = 'wall';
  let brush = 1; let leveeDefault = 2;
  let showHeat = false; let showZ = true;
  let scenario = 'riverine';
  let seedStr = '';

  // Camera offset (center map)
  let camX = 0, camY = 40;

  // ‚Äî‚Äî‚Äî DOM ‚Äî‚Äî‚Äî
  const cvs = document.getElementById('c');
  const ctx = cvs.getContext('2d');
  const tip = document.getElementById('tip');
  const log = document.getElementById('log');
  const els = {
    tick: document.getElementById('tick'),
    level: document.getElementById('levelLabel'),
    budget: document.getElementById('budget'),
    score: document.getElementById('score'),
    saved: document.getElementById('saved'),
    floodStrength: document.getElementById('floodStrength'),
    spawnSide: document.getElementById('spawnSide'),
    brush: document.getElementById('brush'),
    leveeH: document.getElementById('leveeH'),
    leveeHLabel: document.getElementById('leveeHLabel'),
    toggleHeat: document.getElementById('toggleHeat'),
    toggleZ: document.getElementById('toggleZ'),
    scenario: document.getElementById('scenario'),
    seed: document.getElementById('seed'),
    btnRegen: document.getElementById('btnRegen'),
    btnShare: document.getElementById('btnShare'),
    floodSec: document.getElementById('floodSec'),
    settleSec: document.getElementById('settleSec'),
    timerLabel: document.getElementById('timerLabel'),
    btnTests: document.getElementById('btnTests')
  };

  // High-DPI canvas scaling for crisp rendering & correct hit-testing
  function setupHiDPI(){
    const dpr = window.devicePixelRatio || 1;
    const rect = cvs.getBoundingClientRect();
    cvs.width = Math.round(rect.width * dpr);
    cvs.height = Math.round(rect.height * dpr);
    ctx.setTransform(1,0,0,1,0,0);
    ctx.scale(dpr, dpr);
  }
  const resizeObserver = new ResizeObserver(()=> setupHiDPI());
  resizeObserver.observe(cvs);

  // ‚Äî‚Äî‚Äî Helpers ‚Äî‚Äî‚Äî
  const idx=(x,y)=> y*N + x;
  const clamp=(v,a,b)=> Math.max(a, Math.min(b, v));
  const inb=(x,y)=> x>=0 && y>=0 && x<N && y<N;
  const fmt = (n)=> (n|0).toLocaleString('en-PH');

  function mulberry32(a){
    return function(){
      let t = a += 0x6D2B79F5;
      t = Math.imul(t ^ t >>> 15, t | 1);
      t ^= t + Math.imul(t ^ t >>> 7, t | 61);
      return ((t ^ t >>> 14) >>> 0) / 4294967296;
    }
  }
  function seededRngFromString(s){
    let h=1779033703^s.length; for(let i=0;i<s.length;i++){ h = Math.imul(h ^ s.charCodeAt(i), 3432918353); h = h<<13|h>>>19; }
    return mulberry32(h);
  }

  // 2D Perlin-like gradient noise (compact) + fBm + domain warping (for natural terrain)
  const PERM = new Uint8Array(512);
  function initPerm(rand){ const p=new Uint8Array(256); for(let i=0;i<256;i++) p[i]=i; for(let i=255;i>0;i--){ const j=(rand()*256)|0; const t=p[i]; p[i]=p[j%256]; p[j%256]=t; } for(let i=0;i<512;i++) PERM[i]=p[i&255]; }
  const GRAD = [[1,1],[ -1,1],[1,-1],[-1,-1],[1,0],[-1,0],[0,1],[0,-1]];
  const fade=t=>t*t*t*(t*(t*6-15)+10);
  const lerp=(a,b,t)=>a+(b-a)*t;
  function gradDot(hash,x,y){ const g=GRAD[hash&7]; return g[0]*x+g[1]*y; }
  function perlin2(x,y){
    const X=Math.floor(x)&255, Y=Math.floor(y)&255;
    x-=Math.floor(x); y-=Math.floor(y);
    const u=fade(x), v=fade(y);
    const aa=PERM[X+PERM[Y]], ab=PERM[X+PERM[Y+1]], ba=PERM[X+1+PERM[Y]], bb=PERM[X+1+PERM[Y+1]];
    return lerp(
      lerp(gradDot(aa,x,y), gradDot(ba,x-1,y), u),
      lerp(gradDot(ab,x,y-1), gradDot(bb,x-1,y-1), u), v);
  }
  function fbm(x,y,oct=5, lac=2, gain=0.5){ let amp=1, freq=1, sum=0; for(let i=0;i<oct;i++){ sum += amp*perlin2(x*freq, y*freq); amp*=gain; freq*=lac; } return sum; }
  function warpedNoise(x,y){
    // Domain warp for more natural, less banded terrain (see Quilez)
    const w1 = fbm(x*0.08, y*0.08, 3, 2.0, 0.5);
    const w2 = fbm((x+100)*0.08, (y-100)*0.08, 3, 2.0, 0.5);
    const dx = w1*2.0, dy = w2*2.0;
    return fbm((x+dx)*0.06, (y+dy)*0.06, 5, 2.1, 0.5);
  }

  // Isometric projection
  const halfW = TILE_W/2, halfH = TILE_H/2;
  function worldToScreen(gx, gy, z=0){
    const sx = (gx - gy)*halfW + camX + cvs.clientWidth/2;
    const sy = (gx + gy)*halfH - (showZ? z*Z_SCALE:0) + camY + 20;
    return [sx, sy];
  }
  function screenToWorld(sx, sy){
    const x = sx - (camX + cvs.clientWidth/2);
    const y = sy - (camY + 20);
    const gx = Math.floor((y/halfH + x/halfW)/2);
    const gy = Math.floor((y/halfH - x/halfW)/2);
    return [gx, gy];
  }

  function heatColor01(t){ t = clamp(t,0,1); const h = (220 - 220*t); const s = 85, l = 55; return `hsl(${h} ${s}% ${l}%)`; }

  // ‚Äî‚Äî‚Äî Level generation ‚Äî‚Äî‚Äî
  function genLevel(seed=Date.now(), scen='riverine'){
    // Initialize RNG & permutation table for smooth noise
    seedStr = (typeof seed === 'string') ? seed : String(seed);
    const R = seededRngFromString(seedStr);
    initPerm(R);

    elevation = new Array(N*N).fill(0);
    water = new Array(N*N).fill(0);
    type = new Array(N*N).fill(0); // 0 empty, 1 wall, 2 tree, 3 canal
    levee = new Array(N*N).fill(0);
    city = new Array(N*N).fill(0);
    canalCap = new Array(N*N).fill(0);
    canalNote = new Array(N*N).fill('');

    // Build lifelike terrain: domain-warped fBm, then normalize and bias by scenario
    let min= 1e9, max=-1e9;
    for(let y=0;y<N;y++){
      for(let x=0;x<N;x++){
        const h = warpedNoise(x, y); // smooth & coherent
        elevation[idx(x,y)] = h;
        if(h<min) min=h; if(h>max) max=h;
      }
    }
    for(let i=0;i<elevation.length;i++) elevation[i] = (elevation[i]-min)/(max-min+1e-6);

    // Scenario shaping
    if(scen==='riverine'){
      // Create a river channel from highland (top-left) to lowland (bottom-right)
      for(let y=0;y<N;y++){
        const rx = Math.floor( (y*0.9) + 3*Math.sin(y*0.3) );
        for(let x=rx-1;x<=rx+1;x++) if(inb(x,y)) elevation[idx(x,y)] *= 0.55; // carve valley
      }
    } else if(scen==='coastal'){
      // Lower one edge to sea level, raise inland a bit
      for(let y=0;y<N;y++) for(let x=0;x<N;x++){
        const coast = y/(N-1); // top is sea
        elevation[idx(x,y)] = clamp(elevation[idx(x,y)] - (0.5 - coast)*0.35, 0, 1);
      }
    }

    // Slight Gaussian blur for extra smoothness (1 pass)
    const tmp = elevation.slice();
    const k=[0.27901,0.44198,0.27901];
    for(let y=0;y<N;y++) for(let x=0;x<N;x++){
      let s=0,w=0; for(let dy=-1;dy<=1;dy++) for(let dx=-1;dx<=1;dx++){
        const nx=x+dx, ny=y+dy; if(!inb(nx,ny)) continue; const wgt=k[dx+1]*k[dy+1]; s+= tmp[idx(nx,ny)]*wgt; w+=wgt; }
      elevation[idx(x,y)] = s/(w||1);
    }

    // Place city in lowlands near center (vulnerable floodplain)
    let bestX=N>>1, bestY=N>>1, bestH=1e9;
    for(let y=(N>>1)-3;y<=(N>>1)+3;y++) for(let x=(N>>1)-3;x<=(N>>1)+3;x++) if(inb(x,y)){
      const e = elevation[idx(x,y)]; if(e<bestH){ bestH=e; bestX=x; bestY=y; }
    }
    for(let y=bestY-2;y<=bestY+2;y++) for(let x=bestX-2;x<=bestX+2;x++) if(inb(x,y)) city[idx(x,y)] = (Math.abs(x-bestX)+Math.abs(y-bestY))<=3 ? 1:0;

    // Choose spawn side: from higher average edge
    function edgeAvg(side){ let s=0,c=0; if(side==='N') { for(let x=0;x<N;x++){s+=elevation[idx(x,0)];c++;} }
      if(side==='S'){ for(let x=0;x<N;x++){s+=elevation[idx(x,N-1)];c++;} }
      if(side==='W'){ for(let y=0;y<N;y++){s+=elevation[idx(0,y)];c++;} }
      if(side==='E'){ for(let y=0;y<N;y++){s+=elevation[idx(N-1,y)];c++;} } return s/(c||1); }
    const sides=['N','S','W','E']; sides.sort((a,b)=> edgeAvg(b)-edgeAvg(a)); spawnSide=sides[0];

    // Timers (convert sec ‚Üí ticks)
    floodTicks = Math.round( (parseInt(els.floodSec.value,10)||5) * 1000 / TICK_MS );
    settleTicks = Math.round( (parseInt(els.settleSec.value,10)||5) * 1000 / TICK_MS );
    floodLeft = floodTicks; settleLeft = 0; // start with flood, settle later

    // Reset counters
    tick=0; budget=100000; score=0; savedCount=0; tool='wall'; selectToolButton();

    // Seed UI + URL params
    els.seed.value = seedStr;

    draw();
    write(`Level ${level} ‚Äî ${scen} ‚Äî isometric view. City placed in lowlands; flood spawns from ${spawnSide}.`);
  }

  // ‚Äî‚Äî‚Äî Simulation ‚Äî‚Äî‚Äî
  function step(){
    const strength = parseInt(els.floodStrength.value,10);

    if(floodLeft>0){
      // Flood phase: inject water at edge
      floodLeft--;
      for(let i=0;i<N;i++){
        let x=0,y=0;
        if(spawnSide==='N'){ x=i; y=0; }
        if(spawnSide==='S'){ x=i; y=N-1; }
        if(spawnSide==='W'){ x=0; y=i; }
        if(spawnSide==='E'){ x=N-1; y=i; }
        water[idx(x,y)] = clamp(water[idx(x,y)] + strength*0.05, 0, MAX_WATER);
      }
      if(floodLeft===0){ settleLeft = settleTicks; write('Flood ended. Settling‚Ä¶'); }
    }

    // Flow relaxation
    const next = water.slice();
    for(let y=0;y<N;y++){
      for(let x=0;x<N;x++){
        const i = idx(x,y);
        let w = water[i]; if(w<=0) continue;
        // local head with friction; canals lower effective bed, trees slow
        const canalBed = (type[i]===3? -CANAL_DEPTH:0);
        const h0 = elevation[i] + canalBed + w*0.7 + (type[i]===2? 0.05:0);
        let best = i, bestH = h0, bestIsEdge = false;
        const neigh = [ [1,0],[0,1],[-1,0],[0,-1] ];
        for(const [dx,dy] of neigh){
          const nx=x+dx, ny=y+dy;
          if(!inb(nx,ny)){
            // virtual off-map sink
            const hj = -1; // much lower than any terrain
            if(hj < bestH){ bestH = hj; best = i; bestIsEdge = true; }
            continue;
          }
          const j = idx(nx,ny);
          const canalBias = (type[j]===3? 0.25:0); // stronger attraction to canals
          const wallPenalty = (type[j]===1? 0.25*levee[j]:0);
          const canalBedJ = (type[j]===3? -CANAL_DEPTH:0);
          const hj = elevation[j] + canalBedJ + water[j]*0.65 - canalBias + wallPenalty;
          if(hj < bestH){ bestH = hj; best = j; bestIsEdge = false; }
        }
        if(bestIsEdge){
          const move = Math.min(w*0.6, EDGE_SINK_RATE); // drain off-map
          next[i] = clamp(next[i] - move, 0, MAX_WATER);
          continue;
        }
        if(best !== i){
          // canal saturation: cap inflow up to capacity, overflow spills
          const move = Math.min(w*0.55, 0.7);
          if(type[best]===3){
            const cap = canalCap[best]||CANAL_CAP;
            const room = Math.max(0, cap - water[best]);
            const into = Math.min(move, room);
            next[i] -= into; next[best] = clamp(next[best] + into, 0, MAX_WATER);
            const spill = move - into;
            if(spill>0){ next[i] -= spill*0.5; next[best] = clamp(next[best] + spill*0.5, 0, MAX_WATER); }
          } else {
            next[i] -= move; next[best] = clamp(next[best] + move, 0, MAX_WATER);
          }
        }
      }
    }
    water = next;

    // Overtopping
    for(let y=0;y<N;y++) for(let x=0;x<N;x++){
      const i=idx(x,y); if(type[i]!==1||water[i]<=0) continue;
      const neigh = [ [1,0],[0,1],[-1,0],[0,-1] ];
      for(const [dx,dy] of neigh){
        const nx=x+dx, ny=y+dy; if(!inb(nx,ny)) continue;
        const j=idx(nx,ny);
        const head = (elevation[i]+water[i]) - (elevation[j]+water[j]);
        const threshold = 0.5 + 0.2*levee[i];
        if(head>threshold){ const leak = Math.min(0.3 + 0.05*head, water[i]); water[i]-=leak; water[j]=clamp(water[j]+leak,0,MAX_WATER); }
      }
    }

    // Score update ‚Äî saved city tiles that remain dry
    const dryCity = city.reduce((acc,v,k)=> acc + (v && water[k]<0.15 ? 1:0), 0);
    savedCount = dryCity;

    // Timers + UI
    tick++;
    if(floodLeft>0){ els.timerLabel.textContent = `FLOOD ${Math.ceil(floodLeft)} / ${floodTicks} ticks`; }
    else if(settleLeft>0){ settleLeft--; els.timerLabel.textContent = `SETTLE ${Math.ceil(settleLeft)} / ${settleTicks} ticks`; }
    else if(floodLeft===0 && settleLeft===0){
      // End condition once settle done
      playing=false; updateButtons();
      const spent = 100000-budget;
      const levelScore = Math.max(0, dryCity*250 - Math.floor(spent*0.2));
      score += levelScore;
      const totalCity = city.reduce((a,b)=>a+(b?1:0),0) || 1;
      const pct = Math.round(100 * dryCity / totalCity);
      const pass = pct >= PASS_REQ_PCT;
      showResultModal(pass? 'Level Complete üéâ':'Level Failed üíß', pass? 'PASS':'FAIL', dryCity, spent, levelScore, PASS_REQ_PCT);
      write(`${pass? 'Level complete':'Level failed'} ‚Äî Saved ${dryCity}/${totalCity} (${pct}%). Spent ‚Ç±${fmt(spent)}. +${levelScore} pts.`);
      els.timerLabel.textContent = 'complete';
    }

    draw();
  }

  function averageWater(){ let s=0; for(const w of water) s+=w; return s/(N*N); }

  // ‚Äî‚Äî‚Äî Rendering (isometric) ‚Äî‚Äî‚Äî
  function draw(){
    ctx.clearRect(0,0,cvs.width, cvs.height);
    const tiles=[]; for(let y=0;y<N;y++) for(let x=0;x<N;x++) tiles.push([x,y]);
    tiles.sort((a,b)=> (a[0]+a[1]) - (b[0]+b[1]));

    for(const [x,y] of tiles){
      const i=idx(x,y); const z = elevation[i]; const [sx, sy] = worldToScreen(x,y,z);
      const gx = sx, gy = sy;
      const poly = [ [gx,gy], [gx+halfW,gy+halfH], [gx,gy+TILE_H], [gx-halfW,gy+halfH] ];

      // ground ‚Äî earthier palette
      if(showHeat){ ctx.fillStyle = heatColor01((z - 0)/(1-0)); }
      else { const g = Math.floor(80 + z*70); const r = Math.floor(120 + z*25); const b = Math.floor(60 + z*10); ctx.fillStyle = `rgb(${r},${g},${b})`; }
      ctx.beginPath(); for(let k=0;k<4;k++){ const p=poly[k]; if(k===0) ctx.moveTo(p[0],p[1]); else ctx.lineTo(p[0],p[1]); } ctx.closePath(); ctx.fill();

      if(city[i]){ ctx.fillStyle = '#e6a15e'; ctx.globalAlpha=.85; ctx.beginPath(); for(let k=0;k<4;k++){ const p=poly[k]; if(k===0) ctx.moveTo(p[0]+0, p[1]+4); else ctx.lineTo(p[0]+0, p[1]+4); } ctx.closePath(); ctx.fill(); ctx.globalAlpha=1; }

      if(type[i]===1){
        const h = levee[i]||0; ctx.fillStyle = '#8a8fa8';
        ctx.beginPath(); ctx.moveTo(gx,gy); ctx.lineTo(gx+halfW,gy+halfH); ctx.lineTo(gx,gy+TILE_H); ctx.lineTo(gx-halfW,gy+halfH); ctx.closePath(); ctx.fill();
        ctx.globalAlpha = 0.25 + 0.08*h; ctx.fillStyle = '#d6d9e8'; ctx.beginPath(); ctx.moveTo(gx,gy - h*2); ctx.lineTo(gx+halfW,gy+halfH - h*2); ctx.lineTo(gx,gy+TILE_H - h*2); ctx.lineTo(gx-halfW,gy+halfH - h*2); ctx.closePath(); ctx.fill(); ctx.globalAlpha=1;
      } else if(type[i]===2){ ctx.fillStyle = '#2e9158'; ctx.beginPath(); ctx.arc(gx, gy+halfH, 8, 0, Math.PI*2); ctx.fill(); }
      else if(type[i]===3){ ctx.strokeStyle = '#d14deb'; ctx.lineWidth = 2.5; ctx.beginPath(); ctx.moveTo(gx,gy); ctx.lineTo(gx+halfW,gy+halfH); ctx.lineTo(gx,gy+TILE_H); ctx.lineTo(gx-halfW,gy+halfH); ctx.closePath(); ctx.stroke(); }

      const w = water[i]; if(w>0.01){ const a = Math.min(0.85, 0.15 + w*0.14); ctx.fillStyle = `rgba(60,140,255,${a})`; ctx.beginPath(); for(let k=0;k<4;k++){ const p=poly[k]; if(k===0) ctx.moveTo(p[0],p[1]); else ctx.lineTo(p[0],p[1]); } ctx.closePath(); ctx.fill(); }

      ctx.strokeStyle = 'rgba(255,255,255,0.06)'; ctx.lineWidth=1; ctx.beginPath(); for(let k=0;k<4;k++){ const p=poly[k]; if(k===0) ctx.moveTo(p[0],p[1]); else ctx.lineTo(p[0],p[1]); } ctx.closePath(); ctx.stroke();
    }

    // HUD
    els.tick.textContent = tick;
    els.level.textContent = level;
    els.budget.textContent = `‚Ç±${fmt(budget)}`;
    els.score.textContent = fmt(score);
    els.saved.textContent = savedCount;
  }

  function write(msg){ const p=document.createElement('div'); p.textContent = `[${new Date().toLocaleTimeString()}] ${msg}`; log.prepend(p); }

  // ‚Äî‚Äî‚Äî Controls ‚Äî‚Äî‚Äî
  let isDragging=false, lastPt=null; let pan=false; let hoverGX=-1, hoverGY=-1;

  function placeAt(gx,gy){
    for(let by=-Math.floor(brush/2); by<=Math.floor(brush/2); by++){
      for(let bx=-Math.floor(brush/2); bx<=Math.floor(brush/2); bx++){
        const nx=gx+bx, ny=gy+by; if(!inb(nx,ny)) continue; const i=idx(nx,ny);
        if(tool==='erase'){
          if(type[i]){ budget += Math.round(COST[invType(type[i])]*REFUND); type[i]=0; levee[i]=0; }
        } else if(tool==='wall' || tool==='tree' || tool==='canal'){
          const cost=COST[tool]; if(budget>=cost && !city[i]){
            type[i] = tool==='wall'?1: tool==='tree'?2:3;
            if(type[i]===1) levee[i]=leveeDefault;
            if(type[i]===3){ canalCap[i]=CANAL_CAP; }
            budget -= cost;
          }
        }
      }
    }
    draw();
  }

  function invType(t){ return t===1? 'wall': t===2? 'tree':'canal'; }

  function getCanvasPoint(evt){ const rect=cvs.getBoundingClientRect(); const x = (evt.clientX - rect.left); const y = (evt.clientY - rect.top); return [x,y]; }

  function updateTooltip(sx,sy){
    const [gx,gy] = screenToWorld(sx,sy);
    hoverGX=gx; hoverGY=gy;
    if(!inb(gx,gy)){ tip.style.display='none'; return; }
    const i=idx(gx,gy);
    tip.style.display='block';
    tip.style.left = (sx+14)+"px"; tip.style.top=(sy+14)+"px";
    tip.innerHTML = `(${gx},${gy})<br>elev: ${elevation[i].toFixed(2)}<br>water: ${water[i].toFixed(2)}<br>levee: ${levee[i]||0}`;
  }

  cvs.addEventListener('mousemove', e=>{
    const [sx,sy]=getCanvasPoint(e);
    updateTooltip(sx,sy);
    if(!isDragging) return;
    if(pan && lastPt){ camX += (sx-lastPt[0]); camY += (sy-lastPt[1]); lastPt=[sx,sy]; draw(); return; }
    const [gx,gy] = screenToWorld(sx,sy);
    placeAt(gx,gy); lastPt=[sx,sy];
  });
  cvs.addEventListener('mouseleave', ()=>{ tip.style.display='none'; });
  cvs.addEventListener('mousedown', e=>{
    const [sx,sy]=getCanvasPoint(e);
    const [gx,gy] = screenToWorld(sx,sy);
    if(tool==='pan'){ isDragging=true; pan=true; lastPt=[sx,sy]; return; }
    isDragging=true; placeAt(gx,gy); lastPt=[sx,sy];
  });
  window.addEventListener('mouseup', ()=>{ isDragging=false; pan=false; lastPt=null; });

  // Tool buttons
  const toolButtons=[...document.querySelectorAll('button[data-tool]')];
  function selectToolButton(){ toolButtons.forEach(b=> b.classList.toggle('active', b.dataset.tool===tool)); }
  toolButtons.forEach(b=> b.addEventListener('click',()=>{ tool=b.dataset.tool; selectToolButton(); }));

  // Sliders/toggles (guard against nulls)
  if(els.spawnSide) els.spawnSide.addEventListener('change',()=> spawnSide=els.spawnSide.value);
  if(els.brush) els.brush.addEventListener('input',()=> brush=parseInt(els.brush.value,10));
  if(els.leveeH) els.leveeH.addEventListener('input',()=>{ leveeDefault=parseInt(els.leveeH.value,10); els.leveeHLabel.textContent=`h=${leveeDefault}`; });
  if(els.toggleHeat) els.toggleHeat.addEventListener('click',()=>{ showHeat=!showHeat; draw(); });
  if(els.toggleZ) els.toggleZ.addEventListener('click',()=>{ showZ=!showZ; draw(); });

  // Scenario/seed controls
  if(els.scenario) els.scenario.addEventListener('change',()=>{ scenario=els.scenario.value; genLevel(els.seed.value||Date.now(), scenario); });
  if(els.btnRegen) els.btnRegen.addEventListener('click',()=>{ genLevel(els.seed.value||Date.now(), els.scenario.value); });
  if(els.btnShare) els.btnShare.addEventListener('click',()=>{
    const params = new URLSearchParams({ seed: els.seed.value||seedStr, scenario: els.scenario.value });
    const url = `${location.origin}${location.pathname}?${params.toString()}`;
    navigator.clipboard.writeText(url).then(()=> write('Share URL copied to clipboard.')).catch(()=> write('Copy failed.')); });
  if(els.floodSec) els.floodSec.addEventListener('input',()=>{ floodTicks = Math.round(parseInt(els.floodSec.value,10)*1000/TICK_MS); floodLeft=floodTicks; });
  if(els.settleSec) els.settleSec.addEventListener('input',()=>{ settleTicks = Math.round(parseInt(els.settleSec.value,10)*1000/TICK_MS); });

  // Transport
  const btnPlay=document.getElementById('btnPlay');
  const btnStep=document.getElementById('btnStep');
  const btnReset=document.getElementById('btnReset');
  const btnPrev=document.getElementById('btnPrev');
  const btnNext=document.getElementById('btnNext');
  const btnRetry=document.getElementById('btnRetry');
  const btnNext2=document.getElementById('btnNext2');
  const modal=document.getElementById('modal');
  const mTitle=document.getElementById('modalTitle');
  const mStatus=document.getElementById('modalStatus');
  const mSaved=document.getElementById('mSaved');
  const mSpent=document.getElementById('mSpent');
  const mScore=document.getElementById('mScore');
  const mReq=document.getElementById('mReq');

  function updateButtons(){ btnPlay.textContent = playing? '‚è∏ Pause':'‚ñ∂ Play'; }
  btnPlay.addEventListener('click',()=>{ playing=!playing; updateButtons(); });
  btnStep.addEventListener('click',()=> step());
  btnReset.addEventListener('click',()=> genLevel(els.seed.value||Date.now(), els.scenario.value));
  btnPrev.addEventListener('click',()=>{ level=Math.max(1,level-1); genLevel(els.seed.value||Date.now(), els.scenario.value); });
  btnNext.addEventListener('click',()=>{ level++; genLevel(els.seed.value||Date.now(), els.scenario.value); });
  btnRetry.addEventListener('click',()=>{ hideResultModal(); genLevel(els.seed.value||Date.now(), els.scenario.value); });
  btnNext2.addEventListener('click',()=>{ hideResultModal(); level++; genLevel(els.seed.value||Date.now(), els.scenario.value); });

  function showResultModal(title, status, saved, spent, gained, reqPct){
    mTitle.textContent = title; mStatus.textContent = status;
    mSaved.textContent = saved; mSpent.textContent = `‚Ç±${fmt(spent)}`; mScore.textContent = fmt(gained); mReq.textContent = `${reqPct}%`;
    modal.style.display='flex';
  }
  function hideResultModal(){ modal.style.display='none'; }

  // Smoke tests (basic runtime checks)
  function runSmokeTests(){
    let pass=true; const msgs=[];
    function ok(cond, name){ if(!cond){ pass=false; msgs.push(`‚ùå ${name}`);} else msgs.push(`‚úÖ ${name}`); }
    ok(!!cvs, '#c canvas exists');
    ok(!!ctx, '2D context created');
    ok(!!els.floodStrength, '#floodStrength exists');
    ok(!!els.spawnSide, '#spawnSide exists');
    ok(!!els.toggleHeat && !!els.toggleZ, 'toggle buttons exist');
    // isometric pick roundtrip (approx)
    const wpt=[5,8], spt=worldToScreen(wpt[0],wpt[1],0), gpt=screenToWorld(spt[0],spt[1]);
    ok(Math.abs(gpt[0]-wpt[0])<=1 && Math.abs(gpt[1]-wpt[1])<=1, 'iso pick roundtrip ~correct');
    // terrain smoothness heuristic
    let diffSum=0, cnt=0; for(let y=0;y<N;y++) for(let x=0;x<N;x++){
      const i=idx(x,y); if(x+1<N){ diffSum+=Math.abs(elevation[i]-elevation[idx(x+1,y)]); cnt++; }
      if(y+1<N){ diffSum+=Math.abs(elevation[i]-elevation[idx(x,y+1)]); cnt++; }
    }
    const avgDiff = diffSum/(cnt||1); msgs.push(`‚Ñπ avg elev neighbor delta: ${avgDiff.toFixed(3)}`);
    write((pass? 'Tests passed':'Tests found issues')+': '+msgs.join(' | '));
  }
  const btnTests = els.btnTests; if(btnTests) btnTests.addEventListener('click', runSmokeTests);

  // Main loop
  setInterval(()=>{ if(playing) step(); }, TICK_MS);

  // Init (read share URL)
  setupHiDPI();
  const qs = new URLSearchParams(location.search);
  scenario = qs.get('scenario')||'riverine'; els.scenario.value=scenario;
  const seedParam = qs.get('seed');
  const initSeed = seedParam || Date.now();
  genLevel(initSeed, scenario);
  runSmokeTests();
})();
});
</script>
</body>
</html>
